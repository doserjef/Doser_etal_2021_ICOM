
model {

  # Priors ----------------------------------------------------------------
  # Initial occupancy -----------------
  int.psi.0 ~ dunif(0, 1)
  beta.psi.0 <- logit(int.psi.0)
  beta.psi.1 ~ dnorm(0, 0.1)
  # Persistence -----------------------
  int.phi.0 ~ dunif(0, 1)
  beta.phi.0 <- logit(int.phi.0)
  beta.phi.1 ~ dnorm(0, 0.1)
  # Colonization ----------------------
  int.gamma.0 ~ dunif(0, 1)
  beta.gamma.0 <- logit(int.gamma.0) 
  beta.gamma.1 ~ dnorm(0, 0.1)
  # eBird Data ------------------------
  int.alpha.eb.0 ~ dunif(0, 1)
  alpha.eb.0 <- logit(int.alpha.eb.0) 
  alpha.eb.1 ~ dnorm(0, 0.1)
  # HB Data ---------------------------
  int.alpha.hb.0 ~ dunif(0, 1)
  alpha.hb.0 <- logit(int.alpha.hb.0) 
  alpha.hb.1 ~ dnorm(0, 0.1)
  # NEON data -------------------------
  int.alpha.neon.0 ~ dunif(0, 1)
  alpha.neon.0 <- logit(int.alpha.neon.0) 
  alpha.neon.1 ~ dnorm(0, 0.1)

  # Initial Occupancy Process ---------------------------------------------
  for (i in 1:R) {
    logit(psi.0[i]) <- beta.psi.0 + beta.psi.1 * X.psi[i, 2]
    z[i, 1] ~ dbern(psi.0[i])
  } # i 

  for (t in 1:(n.years - 1)) {
    # Persistence and colonization ----------------------------------------
    for (i in 1:R) {
      logit(phi[i, t]) <- beta.phi.0 + beta.phi.1 * X.phi[i, t, 2]
      logit(gamma[i, t]) <- beta.gamma.0 + 
                            beta.gamma.1 * X.gamma[i, t, 2]
      z[i, t + 1] ~ dbern(z[i, t] * phi[i, t] + (1 - z[i, t]) * gamma[i, t])
    } # i
  } # t
  
  for (t in 1:n.years) {
    # Likelihoods ---------------------------------------------------------
    # HB Data -----------------------
    for (i in 1:R.hb) {
      for (j in 1:J.hb) {
        logit(p.hb[i, j, t]) <- alpha.hb.0 + alpha.hb.1 * X.hb[i, j, t, 2]
        C[i, j, t] ~ dbern(p.hb[i, j, t] * z[pixel.hb[i], t])
      } # j 
    } # i 

    # eBird Data --------------------
    for (l in 1:R.eb) {
      # Change of support for eBird
      z.eb[l, t] <- ifelse(sum(z[low[l]:high[l], t]) > 0, 1, 0)
      for (j in 1:J.eb) {
        logit(p.eb[j, l, t]) <- alpha.eb.0 + alpha.eb.1 * X.eb[l, j, t, 2]
        y[j, l, t] ~ dbern(z.eb[l, t] * p.eb[j, l, t])
      } # j
    } # l
   
    # NEON Data ---------------------
    for (i in 1:R.neon) {
      for (j in 1:J.neon) {
        logit(p.neon[i, j, t]) <- alpha.neon.0 + 
                                     alpha.neon.1 * X.neon[i, j, t, 2]
        x[i, j, t] ~ dbern(p.neon[i, j, t] * z[pixel.neon[i], t])
      } # j
    } # i
  } # t
}
